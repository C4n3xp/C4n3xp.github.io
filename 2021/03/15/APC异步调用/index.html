<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="KAPCAPC是从属于每个线程的，APC使用KAPC结构来表示 其中成员Thread是所属的线程 ApcListEntry将线程的所有APC都连接起来 KernelRoutine指向释放KAPC结构的函数 RundownRoutine指向线程终止时，剩余的APC的处理函数 NormalRoutine指向APC要执行的函数地址 ApcMode指定是UserMode的还是KernelMode的APC">
<meta property="og:type" content="article">
<meta property="og:title" content="APC异步调用">
<meta property="og:url" content="http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/index.html">
<meta property="og:site_name" content="sh1xo&#39;s Blog">
<meta property="og:description" content="KAPCAPC是从属于每个线程的，APC使用KAPC结构来表示 其中成员Thread是所属的线程 ApcListEntry将线程的所有APC都连接起来 KernelRoutine指向释放KAPC结构的函数 RundownRoutine指向线程终止时，剩余的APC的处理函数 NormalRoutine指向APC要执行的函数地址 ApcMode指定是UserMode的还是KernelMode的APC">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-15T05:32:18.000Z">
<meta property="article:modified_time" content="2022-04-10T05:46:18.466Z">
<meta property="article:author" content="sh1xo">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>APC异步调用</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">

    
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
    <!-- jquery -->
    
<script src="/lib/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.1.0"></head>

<body>
    <div class="banner">
<div id="blogtitel" class="blogtitel">sh1xo&#39;s Blog</div>
<ul id="wrapper" class="wrapper">
  <div class="sun">
    <div class="star"></div>
  </div>
  <div class="mercury">
    <div class="planet">
      <div class="shadow"></div>
    </div>
  </div>
  <div class="venus">
    <div class="planet">
      <div class="shadow"></div>
    </div>
  </div>
  <div class="earth">
    <div class="planet"><div class="shadow"></div></div>
  </div>
  <div class="mars">
    <div class="planet"><div class="shadow"></div></div>
  </div>
  <div class="jupiter">
    <div class="planet"><div class="shadow"></div></div>
  </div>
</ul>
</div>

    <div class="background">
      
        <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/03/20/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li>
        
        
        <li><a class="icon" href="/2021/03/12/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&text=APC异步调用"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&is_video=false&description=APC异步调用"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=APC异步调用&body=Check out this article: http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&name=APC异步调用&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#KAPC"><span class="toc-number">1.</span> <span class="toc-text">KAPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApcState"><span class="toc-number">2.</span> <span class="toc-text">ApcState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NtQueueApcThread"><span class="toc-number">3.</span> <span class="toc-text">NtQueueApcThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KeInitializeApc"><span class="toc-number">4.</span> <span class="toc-text">KeInitializeApc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KeInsertQueueApc"><span class="toc-number">5.</span> <span class="toc-text">KeInsertQueueApc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APC%E6%89%A7%E8%A1%8C"><span class="toc-number">6.</span> <span class="toc-text">APC执行</span></a></li></ol>
    </div>
  </span>
</div>

      
      <div class="content index width mx-auto px2 my4">
          
          <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        APC异步调用
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">sh1xo's Blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2021-03-15T05:32:18.000Z" itemprop="datePublished">2021-03-15</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="KAPC"><a href="#KAPC" class="headerlink" title="KAPC"></a>KAPC</h2><p>APC是从属于每个线程的，APC使用KAPC结构来表示</p>
<p>其中成员Thread是所属的线程</p>
<p>ApcListEntry将线程的所有APC都连接起来</p>
<p>KernelRoutine指向释放KAPC结构的函数</p>
<p>RundownRoutine指向线程终止时，剩余的APC的处理函数</p>
<p>NormalRoutine指向APC要执行的函数地址</p>
<p>ApcMode指定是UserMode的还是KernelMode的APC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _kapc</span><br><span class="line">ntdll!_KAPC</span><br><span class="line">   +<span class="number">0x000</span> Type             : UChar</span><br><span class="line">   +<span class="number">0x001</span> SpareByte0       : UChar</span><br><span class="line">   +<span class="number">0x002</span> Size             : UChar</span><br><span class="line">   +<span class="number">0x003</span> SpareByte1       : UChar</span><br><span class="line">   +<span class="number">0x004</span> SpareLong0       : Uint4B</span><br><span class="line">   +<span class="number">0x008</span> Thread           : Ptr64 _KTHREAD</span><br><span class="line">   +<span class="number">0x010</span> ApcListEntry     : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x020</span> KernelRoutine    : Ptr64     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x028</span> RundownRoutine   : Ptr64     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x030</span> NormalRoutine    : Ptr64     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x038</span> NormalContext    : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> SystemArgument1  : Ptr64 Void</span><br><span class="line">   +<span class="number">0x048</span> SystemArgument2  : Ptr64 Void</span><br><span class="line">   +<span class="number">0x050</span> ApcStateIndex    : Char</span><br><span class="line">   +<span class="number">0x051</span> ApcMode          : Char</span><br><span class="line">   +<span class="number">0x052</span> Inserted         : UChar</span><br></pre></td></tr></table></figure>

<h2 id="ApcState"><a href="#ApcState" class="headerlink" title="ApcState"></a>ApcState</h2><p>线程结构体KTHREAD中有几个结构与APC有关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _kthread apcstate</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x050 ApcState : _KAPC_STATE</span><br><span class="line">0: kd&gt; dt _kthread savedapcstate</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x240 SavedApcState : _KAPC_STATE</span><br><span class="line">0: kd&gt; dt _kthread apcstateIndex</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x1f0 ApcStateIndex : UChar</span><br><span class="line">0: kd&gt; dt _kthread apcstatepointer</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x230 ApcStatePointer : [2] Ptr64 _KAPC_STATE </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0: kd&gt; dt _KAPC_STATE</span><br><span class="line">ntdll!_KAPC_STATE</span><br><span class="line">   +0x000 ApcListHead      : [2] _LIST_ENTRY</span><br><span class="line">   +0x020 Process          : Ptr64 _KPROCESS</span><br><span class="line">   +0x028 KernelApcInProgress : UChar</span><br><span class="line">   +0x029 KernelApcPending : UChar</span><br><span class="line">   +0x02a UserApcPending   : UChar</span><br><span class="line"></span><br><span class="line">typedef enum _KAPC_ENVIRONMENT&#123;</span><br><span class="line">    OriginalApcEnvironment,</span><br><span class="line">    AttachedApcEnvironment,</span><br><span class="line">    CurrentApcEnvironment,</span><br><span class="line">    InsertApcEnvironment</span><br><span class="line">&#125;KAPC_ENVIRONMENT;</span><br></pre></td></tr></table></figure>

<p>KAPC_STATE结构将从属于当前线程的所有KAPC结构连接起来</p>
<p>ApcState和SaveApcState是KAPC_STATE类型的成员，ApcStatePointer由两个KAPC_STATE指针构成，ApcStateIndex是KAPC_ENVIRONMENT枚举类型</p>
<p>当一个线程在它所属的进程中运行时，使用的APC链表是ApcState成员，此时ApcStatePointer[0]指向的就是ApcState，并且ApcStateIndex等于0，Process指向当前进程</p>
<p>如果一个线程挂载到另一个进程中时，尚未交付的APC对象从ApcState转移到SaveApcState中，并且ApcStatePointer[0]指向的就是SaveApcState，ApcStatePointer[1]指向的就是ApcState，ApcStateIndex等于1，Process指向挂载的进程，此后插入的APC对象都将进入到ApcState链表中</p>
<p>当线程取消挂载时，首先让属于当前进程的APC对象被交付，然后，将SaveApcState中的APC转移到ApcState中，ApcStatePointer[0]又指向了ApcState，并且设置ApcStateIndex等于0，Process指向原本属于的进程</p>
<p>所以ApcStatePointer[ApcStateIndex]永远指向当前进程环境的KAPC_STATE结构，ApcStatePointer[ApcStateIndex].Process总是指向线程当前所属进程(挂载后即挂载的进程)</p>
<p>注意KAPC_STATE.ApcListHead具有两条链表，ApcListHead[0]即内核APC链表，ApcListHead[1]是用户APC链表</p>
<p>观察KeAttachProcess可以看到ApcState变化的过程，KeAttachProcess核心部分调用了KiAttachProcess</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">KiAttachProcess(Thread, Process, OldIrql, &amp;Thread-&gt;SavedApcState);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VOID</span><br><span class="line"><span class="title function_">KiAttachProcess</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PRKTHREAD Thread,</span></span><br><span class="line"><span class="params">    IN PKPROCESS Process,</span></span><br><span class="line"><span class="params">    IN KIRQL OldIrql,</span></span><br><span class="line"><span class="params">    OUT PRKAPC_STATE SavedApcState</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Save current APC state and initialize a new APC state.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    KiMoveApcState(&amp;Thread-&gt;ApcState, SavedApcState);</span><br><span class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]);</span><br><span class="line">    InitializeListHead(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]);</span><br><span class="line">    Thread-&gt;ApcState.Process = Process;</span><br><span class="line">    Thread-&gt;ApcState.KernelApcInProgress = FALSE;</span><br><span class="line">    Thread-&gt;ApcState.KernelApcPending = FALSE;</span><br><span class="line">    Thread-&gt;ApcState.UserApcPending = FALSE;</span><br><span class="line">    <span class="keyword">if</span> (SavedApcState == &amp;Thread-&gt;SavedApcState) &#123;</span><br><span class="line">        Thread-&gt;ApcStatePointer[<span class="number">0</span>] = &amp;Thread-&gt;SavedApcState;</span><br><span class="line">        Thread-&gt;ApcStatePointer[<span class="number">1</span>] = &amp;Thread-&gt;ApcState;</span><br><span class="line">        Thread-&gt;ApcStateIndex = <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先KiMoveApcState将ApcState转移到SaveApcState</p>
<p>接着重新初始化ApcState，Process指向了挂载的进程</p>
<p>ApcStatePointer[0]指向了原来的APC链表</p>
<p>ApcStatePointer[0]指向了新的APC链表</p>
<p>ApcStateIndex&#x3D;1，即AttachedApcEnvironme，这样ApcStatePointer[ApcStateIndex]就指向了新的ApcState</p>
<p>观察KeDetachProcess，代码很清晰，和上面描述的一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">KeDetachProcess</span> <span class="params">(</span></span><br><span class="line"><span class="params">    VOID</span></span><br><span class="line"><span class="params">    )</span> </span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Restore APC state and check whether the kernel APC queue contains</span></span><br><span class="line">        <span class="comment">// an entry. If the kernel APC queue contains an entry then set kernel</span></span><br><span class="line">        <span class="comment">// APC pending and request a software interrupt at APC_LEVEL.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        KiMoveApcState(&amp;Thread-&gt;SavedApcState, &amp;Thread-&gt;ApcState);</span><br><span class="line">        Thread-&gt;SavedApcState.Process = (PKPROCESS)<span class="literal">NULL</span>;</span><br><span class="line">        Thread-&gt;ApcStatePointer[<span class="number">0</span>] = &amp;Thread-&gt;ApcState;</span><br><span class="line">        Thread-&gt;ApcStatePointer[<span class="number">1</span>] = &amp;Thread-&gt;SavedApcState;</span><br><span class="line">        Thread-&gt;ApcStateIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]) == FALSE) &#123;</span><br><span class="line">            Thread-&gt;ApcState.KernelApcPending = TRUE;</span><br><span class="line">            KiRequestSoftwareInterrupt(APC_LEVEL);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NtQueueApcThread"><a href="#NtQueueApcThread" class="headerlink" title="NtQueueApcThread"></a>NtQueueApcThread</h2><p>插入用户APC调用NtQueueApcThread，函数比较简短</p>
<p>首先通过线程句柄获得线程对象</p>
<p>检查是否是系统线程，系统线程不允许插入用户APC</p>
<p>不是系统线程则初始化一个KAPC结构，注意KernelRoutine参数传的是PspQueueApcSpecailApc，这个函数只是简单的释放了KAPC结构</p>
<p>NormalRoutine参数传的是用户指定的APC例程</p>
<p>最后插入目标线程APC链表，等待执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">NTAPI</span><br><span class="line"><span class="title function_">NtQueueApcThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE ThreadHandle,</span></span><br><span class="line"><span class="params">    IN PPS_APC_ROUTINE ApcRoutine,</span></span><br><span class="line"><span class="params">    IN PVOID ApcArgument1,</span></span><br><span class="line"><span class="params">    IN PVOID ApcArgument2,</span></span><br><span class="line"><span class="params">    IN PVOID ApcArgument3</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This function is used to queue a user-mode APC to the specified thread. The APC</span></span><br><span class="line"><span class="comment">    will fire when the specified thread does an alertable wait</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ThreadHandle - Supplies a handle to a thread object.  The caller</span></span><br><span class="line"><span class="comment">        must have THREAD_SET_CONTEXT access to the thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ApcRoutine - Supplies the address of the APC routine to execute when the</span></span><br><span class="line"><span class="comment">        APC fires.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ApcArgument1 - Supplies the first PVOID passed to the APC</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ApcArgument2 - Supplies the second PVOID passed to the APC</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ApcArgument3 - Supplies the third PVOID passed to the APC</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Returns an NT Status code indicating success or failure of the API</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span> </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    PETHREAD Thread;</span><br><span class="line">    NTSTATUS st;</span><br><span class="line">    KPROCESSOR_MODE Mode;</span><br><span class="line">    PKAPC Apc;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    Mode = KeGetPreviousMode ();</span><br><span class="line"></span><br><span class="line">    st = ObReferenceObjectByHandle (ThreadHandle,</span><br><span class="line">                                    THREAD_SET_CONTEXT,</span><br><span class="line">                                    PsThreadType,</span><br><span class="line">                                    Mode,</span><br><span class="line">                                    &amp;Thread,</span><br><span class="line">                                    <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS (st)) &#123;</span><br><span class="line">        st = STATUS_SUCCESS;</span><br><span class="line">        <span class="keyword">if</span> (IS_SYSTEM_THREAD (Thread)) &#123;</span><br><span class="line">            st = STATUS_INVALID_HANDLE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Apc = ExAllocatePoolWithQuotaTag (NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(*Apc),</span><br><span class="line">                                              <span class="string">&#x27;pasP&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Apc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st = STATUS_NO_MEMORY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                KeInitializeApc (Apc,</span><br><span class="line">                                 &amp;Thread-&gt;Tcb,</span><br><span class="line">                                 OriginalApcEnvironment,</span><br><span class="line">                                 PspQueueApcSpecialApc,</span><br><span class="line">                                 <span class="literal">NULL</span>,</span><br><span class="line">                                 (PKNORMAL_ROUTINE)ApcRoutine,</span><br><span class="line">                                 UserMode,</span><br><span class="line">                                 ApcArgument1);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!KeInsertQueueApc (Apc, ApcArgument2, ApcArgument3, <span class="number">0</span>)) &#123;</span><br><span class="line">                    ExFreePool (Apc);</span><br><span class="line">                    st = STATUS_UNSUCCESSFUL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ObDereferenceObject (Thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KeInitializeApc"><a href="#KeInitializeApc" class="headerlink" title="KeInitializeApc"></a>KeInitializeApc</h2><p>下面来看下APC初始化过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">KeInitializeApc</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PRKAPC Apc,</span></span><br><span class="line"><span class="params">    IN PRKTHREAD Thread,</span></span><br><span class="line"><span class="params">    IN KAPC_ENVIRONMENT Environment,</span></span><br><span class="line"><span class="params">    IN PKKERNEL_ROUTINE KernelRoutine,</span></span><br><span class="line"><span class="params">    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,</span></span><br><span class="line"><span class="params">    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,</span></span><br><span class="line"><span class="params">    IN KPROCESSOR_MODE ApcMode OPTIONAL,</span></span><br><span class="line"><span class="params">    IN PVOID NormalContext OPTIONAL</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This function initializes a kernel APC object. The thread, kernel</span></span><br><span class="line"><span class="comment">    routine, and optionally a normal routine, processor mode, and normal</span></span><br><span class="line"><span class="comment">    context parameter are stored in the APC object.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Apc - Supplies a pointer to a control object of type APC.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Thread - Supplies a pointer to a dispatcher object of type thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Environment - Supplies the environment in which the APC will execute.</span></span><br><span class="line"><span class="comment">        Valid values for this parameter are: OriginalApcEnvironment,</span></span><br><span class="line"><span class="comment">        AttachedApcEnvironment, CurrentApcEnvironment, or InsertApcEnvironment</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    KernelRoutine - Supplies a pointer to a function that is to be</span></span><br><span class="line"><span class="comment">        executed at IRQL APC_LEVEL in kernel mode.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RundownRoutine - Supplies an optional pointer to a function that is to be</span></span><br><span class="line"><span class="comment">        called if the APC is in a thread&#x27;s APC queue when the thread terminates.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NormalRoutine - Supplies an optional pointer to a function that is</span></span><br><span class="line"><span class="comment">        to be executed at IRQL 0 in the specified processor mode. If this</span></span><br><span class="line"><span class="comment">        parameter is not specified, then the ProcessorMode and NormalContext</span></span><br><span class="line"><span class="comment">        parameters are ignored.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ApcMode - Supplies the processor mode in which the function specified</span></span><br><span class="line"><span class="comment">        by the NormalRoutine parameter is to be executed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NormalContext - Supplies a pointer to an arbitrary data structure which is</span></span><br><span class="line"><span class="comment">        to be passed to the function specified by the NormalRoutine parameter.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    None.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ASSERT(Environment &lt;= InsertApcEnvironment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Initialize standard control object header.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Apc-&gt;Type = ApcObject;</span><br><span class="line">    Apc-&gt;Size = <span class="keyword">sizeof</span>(KAPC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Initialize the APC environment, thread address, kernel routine address,</span></span><br><span class="line">    <span class="comment">// rundown routine address, normal routine address, processor mode, and</span></span><br><span class="line">    <span class="comment">// normal context parameter. If the normal routine address is null, then</span></span><br><span class="line">    <span class="comment">// the processor mode is defaulted to KernelMode and the APC is a special</span></span><br><span class="line">    <span class="comment">// APC. Otherwise, the processor mode is taken from the argument list.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Environment == CurrentApcEnvironment) &#123;</span><br><span class="line">        Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        ASSERT((Environment &lt;= Thread-&gt;ApcStateIndex) || (Environment == InsertApcEnvironment));</span><br><span class="line"></span><br><span class="line">        Apc-&gt;ApcStateIndex = (CCHAR)Environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Apc-&gt;Thread = Thread;</span><br><span class="line">    Apc-&gt;KernelRoutine = KernelRoutine;</span><br><span class="line">    Apc-&gt;RundownRoutine = RundownRoutine;</span><br><span class="line">    Apc-&gt;NormalRoutine = NormalRoutine;</span><br><span class="line">    <span class="keyword">if</span> (ARGUMENT_PRESENT(NormalRoutine)) &#123;</span><br><span class="line">        Apc-&gt;ApcMode = ApcMode;</span><br><span class="line">        Apc-&gt;NormalContext = NormalContext;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Apc-&gt;ApcMode = KernelMode;</span><br><span class="line">        Apc-&gt;NormalContext = NIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Apc-&gt;Inserted = FALSE;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般我们插入用户APC时，环境都指定是OriginalApcEnvironment，所以Apc-&gt;ApcStateIndex肯定是OriginalApcEnvironment</p>
<p>如果指定是CurrentApcEnvironment，则ApcStateIndex等于目标线程的ApcStateIndex</p>
<p>值得关注的是，如果不指定NormalRoutine，则默认为内核APC，且NormalContext参数被忽略</p>
<h2 id="KeInsertQueueApc"><a href="#KeInsertQueueApc" class="headerlink" title="KeInsertQueueApc"></a>KeInsertQueueApc</h2><p>APC插入过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN</span><br><span class="line"><span class="title function_">KeInsertQueueApc</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PRKAPC Apc,</span></span><br><span class="line"><span class="params">    IN PVOID SystemArgument1,</span></span><br><span class="line"><span class="params">    IN PVOID SystemArgument2,</span></span><br><span class="line"><span class="params">    IN KPRIORITY Increment</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This function inserts an APC object into the APC queue specifed by the</span></span><br><span class="line"><span class="comment">    thread and processor mode fields of the APC object. If the APC object</span></span><br><span class="line"><span class="comment">    is already in an APC queue or APC queuing is disabled, then no operation</span></span><br><span class="line"><span class="comment">    is performed. Otherwise the APC object is inserted in the specified queue</span></span><br><span class="line"><span class="comment">    and appropriate scheduling decisions are made.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Apc - Supplies a pointer to a control object of type APC.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    SystemArgument1, SystemArgument2 - Supply a set of two arguments that</span></span><br><span class="line"><span class="comment">        contain untyped data provided by the executive.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Increment - Supplies the priority increment that is to be applied if</span></span><br><span class="line"><span class="comment">        queuing the APC causes a thread wait to be satisfied.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    If the APC object is already in an APC queue or APC queuing is disabled,</span></span><br><span class="line"><span class="comment">    then a value of FALSE is returned. Otherwise a value of TRUE is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    BOOLEAN Inserted;</span><br><span class="line">    KLOCK_QUEUE_HANDLE LockHandle;</span><br><span class="line">    KIRQL OldIrql;</span><br><span class="line">    PRKTHREAD Thread;</span><br><span class="line"></span><br><span class="line">    ASSERT_APC(Apc);</span><br><span class="line">    ASSERT(KeGetCurrentIrql() &lt;= DISPATCH_LEVEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock</span></span><br><span class="line">    <span class="comment">// the dispatcher database.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Thread = Apc-&gt;Thread;</span><br><span class="line">    KeAcquireInStackQueuedSpinLockRaiseToSynch(&amp;Thread-&gt;ApcQueueLock, &amp;LockHandle);</span><br><span class="line">    KiLockDispatcherDatabaseAtSynchLevel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If APC queuing is disabled, then set inserted to FALSE. Else save</span></span><br><span class="line">    <span class="comment">// system parameter values in APC object, and attempt to queue APC.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread-&gt;ApcQueueable == FALSE) &#123;</span><br><span class="line">        Inserted = FALSE;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Apc-&gt;SystemArgument1 = SystemArgument1;</span><br><span class="line">        Apc-&gt;SystemArgument2 = SystemArgument2;</span><br><span class="line">        Inserted = KiInsertQueueApc(Apc, Increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC</span></span><br><span class="line">    <span class="comment">// queue lock and lower IRQL to its previous value, and return whether the</span></span><br><span class="line">    <span class="comment">// APC was inserted.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    KiUnlockDispatcherDatabaseFromSynchLevel();</span><br><span class="line">    KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">    <span class="keyword">return</span> Inserted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，想要往一个线程中插入APC，Thread的ApcQueueable标志必须为TRUE</p>
<p>核心代码在KiInsetQueueApc中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN</span><br><span class="line">FASTCALL</span><br><span class="line"><span class="title function_">KiInsertQueueApc</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PKAPC Apc,</span></span><br><span class="line"><span class="params">    IN KPRIORITY Increment</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This function inserts an APC object into a thread&#x27;s APC queue. The address</span></span><br><span class="line"><span class="comment">    of the thread object, the APC queue, and the type of APC are all derived</span></span><br><span class="line"><span class="comment">    from the APC object. If the APC object is already in an APC queue, then</span></span><br><span class="line"><span class="comment">    no opertion is performed and a function value of FALSE is returned. Else</span></span><br><span class="line"><span class="comment">    the APC is inserted in the specified APC queue, its inserted state is set</span></span><br><span class="line"><span class="comment">    to TRUE, and a function value of TRUE is returned. The APC will actually</span></span><br><span class="line"><span class="comment">    be delivered when proper enabling conditions exist.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    N.B. The thread APC queue lock and the dispatcher database lock must both</span></span><br><span class="line"><span class="comment">         be held when this routine is called.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Apc - Supplies a pointer to a control object of type APC.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Increment - Supplies the priority increment that is to be applied if</span></span><br><span class="line"><span class="comment">        queuing the APC causes a thread wait to be satisfied.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    If the APC object is already in an APC queue, then a value of FALSE is</span></span><br><span class="line"><span class="comment">    returned. Else a value of TRUE is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    KPROCESSOR_MODE ApcMode;</span><br><span class="line">    PKAPC ApcEntry;</span><br><span class="line">    PKAPC_STATE ApcState;</span><br><span class="line">    BOOLEAN Inserted;</span><br><span class="line">    PLIST_ENTRY ListEntry;</span><br><span class="line">    PKTHREAD Thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the APC object is already in an APC queue, then set inserted to</span></span><br><span class="line">    <span class="comment">// FALSE. Else insert the APC object in the proper queue, set the APC</span></span><br><span class="line">    <span class="comment">// inserted state to TRUE, check to determine if the APC should be delivered</span></span><br><span class="line">    <span class="comment">// immediately, and set inserted to TRUE.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For multiprocessor performance, the following code utilizes the fact</span></span><br><span class="line">    <span class="comment">// that kernel APC disable count is incremented before checking whether</span></span><br><span class="line">    <span class="comment">// the kernel APC queue is nonempty.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// See KeLeaveCriticalRegion().</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    Thread = Apc-&gt;Thread;</span><br><span class="line">    <span class="keyword">if</span> (Apc-&gt;Inserted) &#123;</span><br><span class="line">        Inserted = FALSE;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Apc-&gt;ApcStateIndex == InsertApcEnvironment) &#123;</span><br><span class="line">            Apc-&gt;ApcStateIndex = Thread-&gt;ApcStateIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ApcState = Thread-&gt;ApcStatePointer[Apc-&gt;ApcStateIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Insert the APC after all other special APC entries selected by</span></span><br><span class="line">        <span class="comment">// the processor mode if the normal routine value is NULL. Else</span></span><br><span class="line">        <span class="comment">// insert the APC object at the tail of the APC queue selected by</span></span><br><span class="line">        <span class="comment">// the processor mode unless the APC mode is user and the address</span></span><br><span class="line">        <span class="comment">// of the special APC routine is exit thread, in which case insert</span></span><br><span class="line">        <span class="comment">// the APC at the front of the list and set user APC pending.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        ApcMode = Apc-&gt;ApcMode;</span><br><span class="line">        <span class="keyword">if</span> (Apc-&gt;NormalRoutine != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ApcMode != KernelMode) &amp;&amp; (Apc-&gt;KernelRoutine == PsExitSpecialApc)) &#123;</span><br><span class="line">                Thread-&gt;ApcState.UserApcPending = TRUE;</span><br><span class="line">                InsertHeadList(&amp;ApcState-&gt;ApcListHead[ApcMode],</span><br><span class="line">                               &amp;Apc-&gt;ApcListEntry);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                InsertTailList(&amp;ApcState-&gt;ApcListHead[ApcMode],</span><br><span class="line">                               &amp;Apc-&gt;ApcListEntry);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ListEntry = ApcState-&gt;ApcListHead[ApcMode].Blink;</span><br><span class="line">            <span class="keyword">while</span> (ListEntry != &amp;ApcState-&gt;ApcListHead[ApcMode]) &#123;</span><br><span class="line">                ApcEntry = CONTAINING_RECORD(ListEntry, KAPC, ApcListEntry);</span><br><span class="line">                <span class="keyword">if</span> (ApcEntry-&gt;NormalRoutine == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ListEntry = ListEntry-&gt;Blink;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            InsertHeadList(ListEntry, &amp;Apc-&gt;ApcListEntry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Apc-&gt;Inserted = TRUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If the APC index from the APC object matches the APC Index of</span></span><br><span class="line">        <span class="comment">// the thread, then check to determine if the APC should interrupt</span></span><br><span class="line">        <span class="comment">// thread execution or sequence the thread out of a wait state.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Apc-&gt;ApcStateIndex == Thread-&gt;ApcStateIndex) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// If the processor mode of the APC is kernel, then check if</span></span><br><span class="line">            <span class="comment">// the APC should either interrupt the thread or sequence the</span></span><br><span class="line">            <span class="comment">// thread out of a Waiting state. Else check if the APC should</span></span><br><span class="line">            <span class="comment">// sequence the thread out of an alertable Waiting state.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ApcMode == KernelMode) &#123;</span><br><span class="line">                Thread-&gt;ApcState.KernelApcPending = TRUE;</span><br><span class="line">                <span class="keyword">if</span> (Thread-&gt;State == Running) &#123;</span><br><span class="line">                    KiRequestApcInterrupt(Thread-&gt;NextProcessor);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((Thread-&gt;State == Waiting) &amp;&amp;</span><br><span class="line">                          (Thread-&gt;WaitIrql == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                          ((Apc-&gt;NormalRoutine == <span class="literal">NULL</span>) ||</span><br><span class="line">                          ((Thread-&gt;KernelApcDisable == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                          (Thread-&gt;ApcState.KernelApcInProgress == FALSE)))) &#123;</span><br><span class="line"></span><br><span class="line">                    KiUnwaitThread(Thread, STATUS_KERNEL_APC, Increment, <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((Thread-&gt;State == Waiting) &amp;&amp;</span><br><span class="line">                      (Thread-&gt;WaitMode == UserMode) &amp;&amp;</span><br><span class="line">                      (Thread-&gt;Alertable || Thread-&gt;ApcState.UserApcPending)) &#123;</span><br><span class="line"></span><br><span class="line">                Thread-&gt;ApcState.UserApcPending = TRUE;</span><br><span class="line">                KiUnwaitThread(Thread, STATUS_USER_APC, Increment, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Inserted = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return whether the APC object was inserted in an APC queue.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Inserted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断APC的Inserted标志，如果为TRUE，表示之前插入过了，直接返回</p>
<p>Thread-&gt;ApcStatePointer[Apc-&gt;ApcStateIndex]取出对应的APC_STATE结构</p>
<p>如果NormalRoutine不为NULL，且ApcMode&#x3D;&#x3D;UserMode，KernelRoutine&#x3D;&#x3D;PsExitSpecialApc，则这个APC是线程被终止时的要插入的APC，所以把UserApcPending置为TRUE，且把这个APC插入到链表头部，让这个线程终止APC尽快得到执行。如果不是线程终止的APC则插入到链表尾部，且UserApcPending不置为TRUE，代表这个APC不急着执行</p>
<p>如果NormalRoutine为NULL，则从对应模式链表尾部开始遍历，找到第一个NormalRoutine为NULL的APC，插到它的后面，从这可以看出NormalRoutine为NULL的APC都依次在链表前面</p>
<p>插入完成，将Apc-&gt;Inserted置为TRUE</p>
<p>如果APC指定的ApcStateIndex和当前线程的ApcStateIndex相等，则观察线程的状态，判断是否将UserApcPending置为TRUE，即让APC尽快得到执行</p>
<p>用户APC条件如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Thread-&gt;State == Waiting) &amp;&amp;</span><br><span class="line">(Thread-&gt;WaitMode == UserMode) &amp;&amp;</span><br><span class="line">(Thread-&gt;Alertable || Thread-&gt;ApcState.UserApcPending))</span><br></pre></td></tr></table></figure>

<h2 id="APC执行"><a href="#APC执行" class="headerlink" title="APC执行"></a>APC执行</h2><p>APC对象成功插入到线程链表以后，在以下的几种情况下会执行APC的交付</p>
<ul>
<li><p>当内核代码离开一个临界区或守护区，也就是在调用KeLevelGuardedRegion或KeLeaveCritiicalRegion时，通过KiCheckForKernelApcDeliver函数直接调用KiDeleverApc，或者调用KiRequestSoftwareInterrupt函数请求一个APC_LEVEL的软件中断。这是因为，当线程进入临界区或守护区时，内核模式APC被禁止了，所以，当离开时，KiCheckForKernelApcDelivery函数被调用，以便即使交付内核模式APC</p>
</li>
<li><p>当一个线程经过一次线程切换而获得控制权时，如果内核模式APC需要被交付，则在函数KiSwapThread函数返回以前，调用KiDeliverApc函数交付该内核模式APC</p>
</li>
<li><p>当系统服务返回时经过KiSystemServiceExit或中断或异常处理函数KiPageFault等返回用户模式时，KiDeliverApc函数被调用以便交付用户模式APC</p>
</li>
<li><p>在APC_LEVEL软件中断发生时，HAL模块中的软件中断处理函数(HalpDispatchSoftwareInterrupt)调用KIDeliverApc交付内核模式APC。当内核代码调用KeLowerIrql函数降低IRQL到PASSIVE_LEVEL时，KiDeliverApc函数也会被调用</p>
</li>
</ul>
<p>KiDeliverDpc负责分发APC</p>
<p>进入这个函数时，IRQL一定为APC_IEVEL</p>
<p>注意ExceptionFrame和TrapFrame只有在PreviousMode是UserMode时才有效，即从系统服务或异常处理函数返回用户模式时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">KiDeliverApc</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN KPROCESSOR_MODE PreviousMode,</span></span><br><span class="line"><span class="params">    IN PKEXCEPTION_FRAME ExceptionFrame,</span></span><br><span class="line"><span class="params">    IN PKTRAP_FRAME TrapFrame</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This function is called from the APC interrupt code and when one or</span></span><br><span class="line"><span class="comment">    more of the APC pending flags are set at system exit and the previous</span></span><br><span class="line"><span class="comment">    IRQL is zero. All special kernel APC&#x27;s are delivered first, followed</span></span><br><span class="line"><span class="comment">    by normal kernel APC&#x27;s if one is not already in progress, and finally</span></span><br><span class="line"><span class="comment">    if the user APC queue is not empty, the user APC pending flag is set,</span></span><br><span class="line"><span class="comment">    and the previous mode is user, then a user APC is delivered. On entry</span></span><br><span class="line"><span class="comment">    to this routine IRQL is set to APC_LEVEL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    N.B. The exception frame and trap frame addresses are only guaranteed</span></span><br><span class="line"><span class="comment">         to be valid if, and only if, the previous mode is user.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    PreviousMode - Supplies the previous processor mode.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TrapFrame - Supplies a pointer to a trap frame.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    None.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span></span><br></pre></td></tr></table></figure>

<p>SList相关，不关注</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the thread was interrupted in the middle of the SLIST pop code,</span></span><br><span class="line"><span class="comment">// then back up the PC to the start of the SLIST pop. </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TrapFrame != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ((TrapFrame-&gt;Eip &gt;= (ULONG)&amp;ExpInterlockedPopEntrySListResume) &amp;&amp;</span><br><span class="line">        (TrapFrame-&gt;Eip &lt;= (ULONG)&amp;ExpInterlockedPopEntrySListEnd)) &#123;</span><br><span class="line"></span><br><span class="line">        TrapFrame-&gt;Eip = (ULONG)&amp;ExpInterlockedPopEntrySListResume;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获得当前线程对象，即线程所属进程对象</p>
<p>保存原来的TrapFrame，设置线程的新TrapFrame</p>
<p>KeAcquireInStackQueuedSpinLock会将IRQL提升到DISPATCH_LEVEL</p>
<p>将当前线程的ApcState的KernelApcPending设为FALSE</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Raise IRQL to dispatcher level and lock the APC queue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">Thread = KeGetCurrentThread();</span><br><span class="line"></span><br><span class="line">OldTrapFrame = Thread-&gt;TrapFrame;</span><br><span class="line">Thread-&gt;TrapFrame = TrapFrame;</span><br><span class="line"></span><br><span class="line">Process = Thread-&gt;ApcState.Process;</span><br><span class="line">KeAcquireInStackQueuedSpinLock(&amp;Thread-&gt;ApcQueueLock, &amp;LockHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get address of current thread object, clear kernel APC pending, and</span></span><br><span class="line"><span class="comment">// check if any kernel mode APC&#x27;s can be delivered.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">Thread-&gt;ApcState.KernelApcPending = FALSE;</span><br></pre></td></tr></table></figure>

<p>先遍历内核APC链表</p>
<p>如果NormalRoutine为NULL，即特殊内核APC，将这个APC从链表中移除，Inserted设为FALSE，并执行其KernelRoutine，执行KernelRoutine时会降低IRQL</p>
<p>如果NormalRoutine不为NULL，且KernelApcInProgress和KernelApcDisable都没有置为TRUE，意为线程没有正在执行的内核APC且线程不禁止内核APC，则将其从链表中移除，Inserted置为FALSE，执行其KernelRoutine。然后执行其NormalRoutine，执行NormalRoutine时IRQL降为0，并将KernelApcInProgress置为TRUE。如果有正在执行的内核APC或线程禁止内核APC，则直接跳到CheckProcess，检查在APC分发期间是否发生了线程挂靠，然后恢复旧的TrapFrame，直接return</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[KernelMode]) == FALSE) &#123;</span><br><span class="line">     NextEntry = Thread-&gt;ApcState.ApcListHead[KernelMode].Flink;</span><br><span class="line">     Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);</span><br><span class="line">     KernelRoutine = Apc-&gt;KernelRoutine;</span><br><span class="line">     NormalRoutine = Apc-&gt;NormalRoutine;</span><br><span class="line">     NormalContext = Apc-&gt;NormalContext;</span><br><span class="line">     SystemArgument1 = Apc-&gt;SystemArgument1;</span><br><span class="line">     SystemArgument2 = Apc-&gt;SystemArgument2;</span><br><span class="line">     <span class="keyword">if</span> (NormalRoutine == (PKNORMAL_ROUTINE)<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// First entry in the kernel APC queue is a special kernel APC.</span></span><br><span class="line">         <span class="comment">// Remove the entry from the APC queue, set its inserted state</span></span><br><span class="line">         <span class="comment">// to FALSE, release dispatcher database lock, and call the kernel</span></span><br><span class="line">         <span class="comment">// routine. On return raise IRQL to dispatcher level and lock</span></span><br><span class="line">         <span class="comment">// dispatcher database lock.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">         RemoveEntryList(NextEntry);</span><br><span class="line">         Apc-&gt;Inserted = FALSE;</span><br><span class="line">         KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">         (KernelRoutine)(Apc,</span><br><span class="line">                         &amp;NormalRoutine,</span><br><span class="line">                         &amp;NormalContext,</span><br><span class="line">                         &amp;SystemArgument1,</span><br><span class="line">                         &amp;SystemArgument2);</span><br><span class="line"></span><br><span class="line">         KeAcquireInStackQueuedSpinLock(&amp;Thread-&gt;ApcQueueLock, &amp;LockHandle);</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// First entry in the kernel APC queue is a normal kernel APC.</span></span><br><span class="line">         <span class="comment">// If there is not a normal kernel APC in progress and kernel</span></span><br><span class="line">         <span class="comment">// APC&#x27;s are not disabled, then remove the entry from the APC</span></span><br><span class="line">         <span class="comment">// queue, set its inserted state to FALSE, release the APC queue</span></span><br><span class="line">         <span class="comment">// lock, call the specified kernel routine, set kernel APC in</span></span><br><span class="line">         <span class="comment">// progress, lower the IRQL to zero, and call the normal kernel</span></span><br><span class="line">         <span class="comment">// APC routine. On return raise IRQL to dispatcher level, lock</span></span><br><span class="line">         <span class="comment">// the APC queue, and clear kernel APC in progress.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> ((Thread-&gt;ApcState.KernelApcInProgress == FALSE) &amp;&amp;</span><br><span class="line">            (Thread-&gt;KernelApcDisable == <span class="number">0</span>)) &#123;</span><br><span class="line">             RemoveEntryList(NextEntry);</span><br><span class="line">             Apc-&gt;Inserted = FALSE;</span><br><span class="line">             KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">             (KernelRoutine)(Apc,</span><br><span class="line">                             &amp;NormalRoutine,</span><br><span class="line">                             &amp;NormalContext,</span><br><span class="line">                             &amp;SystemArgument1,</span><br><span class="line">                             &amp;SystemArgument2);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (NormalRoutine != (PKNORMAL_ROUTINE)<span class="literal">NULL</span>) &#123;</span><br><span class="line">                 Thread-&gt;ApcState.KernelApcInProgress = TRUE;</span><br><span class="line">                 KeLowerIrql(<span class="number">0</span>);</span><br><span class="line">                 (NormalRoutine)(NormalContext,</span><br><span class="line">                                 SystemArgument1,</span><br><span class="line">                                 SystemArgument2);</span><br><span class="line"></span><br><span class="line">                 KeRaiseIrql(APC_LEVEL, &amp;LockHandle.OldIrql);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             KeAcquireInStackQueuedSpinLock(&amp;Thread-&gt;ApcQueueLock, &amp;LockHandle);</span><br><span class="line">             Thread-&gt;ApcState.KernelApcInProgress = FALSE;</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">             <span class="keyword">goto</span> CheckProcess;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>遍历完了内核APC链表，开始查看用户APC链表第一个APC，注意这里不是遍历，所以其实每次只分发一个用户APC</p>
<p>但有两个条件，即先前模式为UserMode且UserApcPending被置为TRUE</p>
<p>这实际上是从系统调用返回途径KiSystemServiceExit、中断、或异常调用的KiDeliverApc</p>
<p>满足条件后，首先将UserApcPending设为FALSE</p>
<p>将当前APC从链表中移除，Inserted设为FALSE，降低IRQL，执行KernelRoutine</p>
<p>如果NormalRoutine为NULL，则警醒当前线程，不做其他操作，继续遍历</p>
<p>如果NormalRoutine不为NULL，则调用KiInitializeUserApc进行用户APC具体操作</p>
<p>最后不管结局如何，恢复线程旧的TrapFrame</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Kernel APC queue is empty. If the previous mode is user, user APC</span></span><br><span class="line">    <span class="comment">// pending is set, and the user APC queue is not empty, then remove</span></span><br><span class="line">    <span class="comment">// the first entry from the user APC queue, set its inserted state to</span></span><br><span class="line">    <span class="comment">// FALSE, clear user APC pending, release the dispatcher database lock,</span></span><br><span class="line">    <span class="comment">// and call the specified kernel routine. If the normal routine address</span></span><br><span class="line">    <span class="comment">// is not NULL on return from the kernel routine, then initialize the</span></span><br><span class="line">    <span class="comment">// user mode APC context and return. Otherwise, check to determine if</span></span><br><span class="line">    <span class="comment">// another user mode APC can be processed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((IsListEmpty(&amp;Thread-&gt;ApcState.ApcListHead[UserMode]) == FALSE) &amp;&amp;</span><br><span class="line">       (PreviousMode == UserMode) &amp;&amp; (Thread-&gt;ApcState.UserApcPending != FALSE)) &#123;</span><br><span class="line">        Thread-&gt;ApcState.UserApcPending = FALSE;</span><br><span class="line">        NextEntry = Thread-&gt;ApcState.ApcListHead[UserMode].Flink;</span><br><span class="line">        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);</span><br><span class="line">        KernelRoutine = Apc-&gt;KernelRoutine;</span><br><span class="line">        NormalRoutine = Apc-&gt;NormalRoutine;</span><br><span class="line">        NormalContext = Apc-&gt;NormalContext;</span><br><span class="line">        SystemArgument1 = Apc-&gt;SystemArgument1;</span><br><span class="line">        SystemArgument2 = Apc-&gt;SystemArgument2;</span><br><span class="line">        RemoveEntryList(NextEntry);</span><br><span class="line">        Apc-&gt;Inserted = FALSE;</span><br><span class="line">        KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">        (KernelRoutine)(Apc,</span><br><span class="line">                        &amp;NormalRoutine,</span><br><span class="line">                        &amp;NormalContext,</span><br><span class="line">                        &amp;SystemArgument1,</span><br><span class="line">                        &amp;SystemArgument2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NormalRoutine == (PKNORMAL_ROUTINE)<span class="literal">NULL</span>) &#123;</span><br><span class="line">            KeTestAlertThread(UserMode);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            KiInitializeUserApc(ExceptionFrame,</span><br><span class="line">                                TrapFrame,</span><br><span class="line">                                NormalRoutine,</span><br><span class="line">                                NormalContext,</span><br><span class="line">                                SystemArgument1,</span><br><span class="line">                                SystemArgument2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        KeReleaseInStackQueuedSpinLock(&amp;LockHandle);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check if process was attached during the APC routine.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">CheckProcess:</span><br><span class="line">    <span class="keyword">if</span> (Thread-&gt;ApcState.Process != Process) &#123;</span><br><span class="line">        KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,</span><br><span class="line">                     (ULONG_PTR)Process,</span><br><span class="line">                     (ULONG_PTR)Thread-&gt;ApcState.Process,</span><br><span class="line">                     (ULONG)Thread-&gt;ApcStateIndex,</span><br><span class="line">                     (ULONG)KeIsExecutingDpc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread-&gt;TrapFrame = OldTrapFrame;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看KiInitializeUserApc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">VOID</span><br><span class="line"><span class="title function_">KiInitializeUserApc</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PKEXCEPTION_FRAME ExceptionFrame,</span></span><br><span class="line"><span class="params">    IN PKTRAP_FRAME TrapFrame,</span></span><br><span class="line"><span class="params">    IN PKNORMAL_ROUTINE NormalRoutine,</span></span><br><span class="line"><span class="params">    IN PVOID NormalContext,</span></span><br><span class="line"><span class="params">    IN PVOID SystemArgument1,</span></span><br><span class="line"><span class="params">    IN PVOID SystemArgument2</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This function is called to initialize the context for a user mode APC.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TrapFrame - Supplies a pointer to a trap frame.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NormalRoutine - Supplies a pointer to the user mode APC routine.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NormalContext - Supplies a pointer to the user context for the APC</span></span><br><span class="line"><span class="comment">        routine.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    SystemArgument1 - Supplies the first system supplied value.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    SystemArgument2 - Supplies the second system supplied value.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    None.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    EXCEPTION_RECORD ExceptionRecord;</span><br><span class="line">    CONTEXT ContextFrame;</span><br><span class="line">    LONG Length;</span><br><span class="line">    ULONG UserStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// APCs are not defined for V86 mode; however, it is possible a</span></span><br><span class="line">    <span class="comment">// thread is trying to set it&#x27;s context to V86 mode - this isn&#x27;t</span></span><br><span class="line">    <span class="comment">// going to work, but we don&#x27;t want to crash the system so we</span></span><br><span class="line">    <span class="comment">// check for the possibility before hand.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Move machine state from trap and exception frames to the context frame.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    ContextFrame.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">    KeContextFromKframes(TrapFrame, ExceptionFrame, &amp;ContextFrame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Transfer the context information to the user stack, initialize the</span></span><br><span class="line">    <span class="comment">// APC routine parameters, and modify the trap frame so execution will</span></span><br><span class="line">    <span class="comment">// continue in user mode at the user mode APC dispatch routine.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ASSERT((TrapFrame-&gt;SegCs &amp; MODE_MASK) != KernelMode); <span class="comment">// Assert usermode frame</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Compute length of context record and new aligned user stack pointer.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        Length = ((<span class="keyword">sizeof</span>(CONTEXT) + CONTEXT_ROUND) &amp;</span><br><span class="line">                    ~CONTEXT_ROUND) + <span class="keyword">sizeof</span>(KAPC_RECORD);</span><br><span class="line">        UserStack = (ContextFrame.Esp &amp; ~CONTEXT_ROUND) - Length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Probe user stack area for writability and then transfer the</span></span><br><span class="line">        <span class="comment">// context record to the user stack.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        ProbeForWrite((PCHAR)UserStack, Length, CONTEXT_ALIGN);</span><br><span class="line">        RtlCopyMemory((PULONG)(UserStack + (<span class="keyword">sizeof</span>(KAPC_RECORD))),</span><br><span class="line">                     &amp;ContextFrame, <span class="keyword">sizeof</span>(CONTEXT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Force correct R3 selectors into TrapFrame.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        TrapFrame-&gt;SegCs = SANITIZE_SEG(KGDT_R3_CODE, UserMode);</span><br><span class="line">        TrapFrame-&gt;HardwareSegSs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);</span><br><span class="line">        TrapFrame-&gt;SegDs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);</span><br><span class="line">        TrapFrame-&gt;SegEs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);</span><br><span class="line">        TrapFrame-&gt;SegFs = SANITIZE_SEG(KGDT_R3_TEB, UserMode);</span><br><span class="line">        TrapFrame-&gt;SegGs = <span class="number">0</span>;</span><br><span class="line">        TrapFrame-&gt;EFlags = SANITIZE_FLAGS( ContextFrame.EFlags, UserMode );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// If thread is supposed to have IOPL, then force it on in eflags</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (KeGetCurrentThread()-&gt;Iopl) &#123;</span><br><span class="line">            TrapFrame-&gt;EFlags |= (EFLAGS_IOPL_MASK &amp; <span class="number">-1</span>);  <span class="comment">// IOPL = 3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Set the address of the user APC routine, the APC parameters, the</span></span><br><span class="line">        <span class="comment">// new frame pointer, and the new stack pointer in the current trap</span></span><br><span class="line">        <span class="comment">// frame. Set the continuation address so control will be transferred</span></span><br><span class="line">        <span class="comment">// to the user APC dispatcher.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        TrapFrame-&gt;HardwareEsp = UserStack;</span><br><span class="line">        TrapFrame-&gt;Eip = (ULONG)KeUserApcDispatcher;</span><br><span class="line">        TrapFrame-&gt;ErrCode = <span class="number">0</span>;</span><br><span class="line">        *((PULONG)UserStack)++ = (ULONG)NormalRoutine;</span><br><span class="line">        *((PULONG)UserStack)++ = (ULONG)NormalContext;</span><br><span class="line">        *((PULONG)UserStack)++ = (ULONG)SystemArgument1;</span><br><span class="line">        *((PULONG)UserStack)++ = (ULONG)SystemArgument2;</span><br><span class="line">    &#125; except (KiCopyInformation(&amp;ExceptionRecord,</span><br><span class="line">                                (GetExceptionInformation())-&gt;ExceptionRecord)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Set the address of the exception to the current program address</span></span><br><span class="line">        <span class="comment">// and raise the exception by calling the exception dispatcher.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        ExceptionRecord.ExceptionAddress = (PVOID)(TrapFrame-&gt;Eip);</span><br><span class="line">        KiDispatchException(&amp;ExceptionRecord,</span><br><span class="line">                            ExceptionFrame,</span><br><span class="line">                            TrapFrame,</span><br><span class="line">                            UserMode,</span><br><span class="line">                            TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是由KiSystemServiceExit或中断异常调用过来的，这里伪造返回R3前夕的TrapFrame</p>
<p>从栈顶开始依次为NormalRoutine，NormalContext，SystemArgument1，SystemArgument2，还有一个CONTEXT结构体</p>
<p>注意返回的Eip被设置为了KeUserApcDispatcher，对应Ntdll中的KiUserApcDispatcher，到这才真正执行了NormalRoutine</p>
<p>然后又调用了NtContinue回到了内核，并恢复了KiSystemServiceExit或中断异常调用KiDeliverApc时的框架</p>
<p>NtContinue系统调用返回时又会经过KiSystemServiceExit，从而再次引发用户APC分发，如此嵌套，直到用户APC链表为空，或UserApcPending为FALSE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC _KiUserApcDispatcher@16</span><br><span class="line">_KiUserApcDispatcher@16:</span><br><span class="line"></span><br><span class="line">    /* Setup SEH stack */</span><br><span class="line">    lea eax, [esp+CONTEXT_ALIGNED_SIZE+16]</span><br><span class="line">    mov ecx, fs:[TEB_EXCEPTION_LIST]</span><br><span class="line">    mov edx, offset _KiUserApcExceptionHandler</span><br><span class="line">    mov [eax], ecx</span><br><span class="line">    mov [eax+4], edx</span><br><span class="line"></span><br><span class="line">    /* Enable SEH */</span><br><span class="line">    mov fs:[TEB_EXCEPTION_LIST], eax</span><br><span class="line"></span><br><span class="line">    /* Put the Context in EDI */</span><br><span class="line">    pop eax</span><br><span class="line">    lea edi, [esp+12]</span><br><span class="line"></span><br><span class="line">    /* Call the APC Routine */</span><br><span class="line">    call eax</span><br><span class="line"></span><br><span class="line">    /* Restore exception list */</span><br><span class="line">    mov ecx, [edi+CONTEXT_ALIGNED_SIZE]</span><br><span class="line">    mov fs:[TEB_EXCEPTION_LIST], ecx</span><br><span class="line"></span><br><span class="line">    /* Switch back to the context */</span><br><span class="line">    push 1</span><br><span class="line">    push edi</span><br><span class="line">    call _ZwContinue@8</span><br><span class="line"></span><br><span class="line">    /* Save callback return value */</span><br><span class="line">    mov esi, eax</span><br><span class="line"></span><br><span class="line">    /* Raise status */</span><br><span class="line">StatusRaiseApc:</span><br><span class="line">    push esi</span><br><span class="line">    call _RtlRaiseStatus@4</span><br><span class="line">    jmp StatusRaiseApc</span><br><span class="line">    ret 16</span><br></pre></td></tr></table></figure>

  </div>
</article>



      </div>
      
       <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#KAPC"><span class="toc-number">1.</span> <span class="toc-text">KAPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApcState"><span class="toc-number">2.</span> <span class="toc-text">ApcState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NtQueueApcThread"><span class="toc-number">3.</span> <span class="toc-text">NtQueueApcThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KeInitializeApc"><span class="toc-number">4.</span> <span class="toc-text">KeInitializeApc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KeInsertQueueApc"><span class="toc-number">5.</span> <span class="toc-text">KeInsertQueueApc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APC%E6%89%A7%E8%A1%8C"><span class="toc-number">6.</span> <span class="toc-text">APC执行</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&text=APC异步调用"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&is_video=false&description=APC异步调用"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=APC异步调用&body=Check out this article: http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&title=APC异步调用"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://sh1xo.cn/2021/03/15/APC%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/&name=APC异步调用&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

      
      <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2022 sh1xo
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

      
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- Google Analytics -->

<!-- Disqus Comments -->


    </div>
</body>
</html>
