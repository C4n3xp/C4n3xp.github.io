<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="页表管理pte_t，pmd_t，pgd_t实际上是长整数 123456789101112131415typedef struct &amp;#123; unsigned long pte_low; &amp;#125; pte_t;typedef struct &amp;#123; unsigned long pmd; &amp;#125; pmd_t;typedef struct &amp;#123; unsigned long pg">
<meta property="og:type" content="article">
<meta property="og:title" content="linux内存管理">
<meta property="og:url" content="https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="sh1xo&#39;s Blog">
<meta property="og:description" content="页表管理pte_t，pmd_t，pgd_t实际上是长整数 123456789101112131415typedef struct &amp;#123; unsigned long pte_low; &amp;#125; pte_t;typedef struct &amp;#123; unsigned long pmd; &amp;#125; pmd_t;typedef struct &amp;#123; unsigned long pg">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-06-01T08:33:37.000Z">
<meta property="article:modified_time" content="2022-05-04T08:34:37.918Z">
<meta property="article:author" content="sh1xo">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>linux内存管理</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">

    
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
    <!-- jquery -->
    
<script src="/lib/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.1.0"></head>

<body>
    <div class="banner">
<div id="blogtitel" class="blogtitel">sh1xo&#39;s Blog</div>
<ul id="wrapper" class="wrapper">
  <div class="sun">
    <div class="star"></div>
  </div>
  <div class="mercury">
    <div class="planet">
      <div class="shadow"></div>
    </div>
  </div>
  <div class="venus">
    <div class="planet">
      <div class="shadow"></div>
    </div>
  </div>
  <div class="earth">
    <div class="planet"><div class="shadow"></div></div>
  </div>
  <div class="mars">
    <div class="planet"><div class="shadow"></div></div>
  </div>
  <div class="jupiter">
    <div class="planet"><div class="shadow"></div></div>
  </div>
</ul>
</div>

    <div class="background">
      
        <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2021/05/01/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&text=linux内存管理"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&is_video=false&description=linux内存管理"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=linux内存管理&body=Check out this article: https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&name=linux内存管理&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">页表管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">物理地址管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">虚拟地址管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">页面交换文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.</span> <span class="toc-text">物理页面生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLAB"><span class="toc-number">6.</span> <span class="toc-text">SLAB</span></a></li></ol>
    </div>
  </span>
</div>

      
      <div class="content index width mx-auto px2 my4">
          
          <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        linux内存管理
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">sh1xo's Blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2021-06-01T08:33:37.000Z" itemprop="datePublished">2021-06-01</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="页表管理"><a href="#页表管理" class="headerlink" title="页表管理"></a>页表管理</h2><p>pte_t，pmd_t，pgd_t实际上是长整数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">unsigned</span> <span class="type">long</span> pte_low; &#125; <span class="type">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">unsigned</span> <span class="type">long</span> pmd; &#125; <span class="type">pmd_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">unsigned</span> <span class="type">long</span> pgd; &#125; <span class="type">pgd_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_val(x)    ((x).pte_low)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">unsigned</span> <span class="type">long</span> pgprot; &#125; <span class="type">pgprot_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pmd_val(x)    ((x).pmd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_val(x)    ((x).pgd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_val(x)    ((x).pgprot)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pte(x) ((pte_t) &#123; (x) &#125; )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pmd(x) ((pmd_t) &#123; (x) &#125; )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pgd(x) ((pgd_t) &#123; (x) &#125; )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pgprot(x)    ((pgprot_t) &#123; (x) &#125; )</span></span><br></pre></td></tr></table></figure>

<p>pgprot_t是说明页面保护的结构，对应页面表项的低12位，其中9位是标志位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PRESENT    0x001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_RW    0x002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_USER    0x004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PWT    0x008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PCD    0x010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_ACCESSED    0x020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_DIRTY    0x040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PSE    0x080    <span class="comment">/* 4 MB (or 2MB) page, Pentium+, if present.. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_GLOBAL    0x100    <span class="comment">/* Global TLB entry PPro+ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_PROTNONE    0x080    <span class="comment">/* If not present */</span></span></span><br></pre></td></tr></table></figure>

<p>pte设置和检测相关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __mk_pte(page_nr,pgprot) __pte(((page_nr) &lt;&lt; PAGE_SHIFT) | pgprot_val(pgprot))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_pte(pteptr, pteval) (*(pteptr) = pteval)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_none(x)        (!(x).pte_low)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_present(x)    ((x).pte_low &amp; (_PAGE_PRESENT | _PAGE_PROTNONE))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pte_read</span><span class="params">(<span class="type">pte_t</span> pte)</span>        &#123; <span class="keyword">return</span> (pte).pte_low &amp; _PAGE_USER; &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pte_exec</span><span class="params">(<span class="type">pte_t</span> pte)</span>        &#123; <span class="keyword">return</span> (pte).pte_low &amp; _PAGE_USER; &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pte_dirty</span><span class="params">(<span class="type">pte_t</span> pte)</span>        &#123; <span class="keyword">return</span> (pte).pte_low &amp; _PAGE_DIRTY; &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pte_young</span><span class="params">(<span class="type">pte_t</span> pte)</span>        &#123; <span class="keyword">return</span> (pte).pte_low &amp; _PAGE_ACCESSED; &#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">pte_write</span><span class="params">(<span class="type">pte_t</span> pte)</span>        &#123; <span class="keyword">return</span> (pte).pte_low &amp; _PAGE_RW; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="物理地址管理"><a href="#物理地址管理" class="headerlink" title="物理地址管理"></a>物理地址管理</h2><p>代表物理页结构的是page数据结构，mem_map是page结构数组，记录了系统中每一个物理页的状态</p>
<p>当页面的内容来自一个文件时，index代表着该页面在文件中的序号，当页面的内容被换出到交换设备上，但还保持着内容作为缓冲时，index指明了页面的去向</p>
<p>当页面空闲时，通过list链入所属zone_struct的free_area空闲队列中</p>
<p>非空闲和分配状态，通过lru链入某个活跃或不活跃链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next_hash</span>;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;    <span class="comment">/* atomic flags, some possibly updated asynchronously */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> age;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pprev_hash</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">buffers</span>;</span></span><br><span class="line">    <span class="type">void</span> *virtual; <span class="comment">/* non-NULL if kmapped */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone_struct</span> *<span class="title">zone</span>;</span></span><br><span class="line">&#125; <span class="type">mem_map_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_page(x)        (mem_map+((unsigned long)(((x).pte_low &gt;&gt; PAGE_SHIFT))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（1G的内核地址空间和物理地址的低1G内存是一一映射的，所以内核空间地址可以直接通过`__pa`计算得到其物理地址）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> virt_to_page(kaddr)    (mem_map + (__pa(kaddr) &gt;&gt; PAGE_SHIFT))</span></span><br></pre></td></tr></table></figure>

<p>物理页面划分为多个管理区，即zone_struct结构</p>
<p>默认有2个管理区，ZONE_DMA和ZONE_NORMAL</p>
<p>free_area是一组空闲队列，保持一些连续长度为2的次方数的页面块</p>
<p>offset表示该分区在mem_map中的起始页面号</p>
<p>zone_pgdat指向此管理区所属的存储节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ORDER 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">free_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">free_list</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        *<span class="built_in">map</span>;</span><br><span class="line">&#125; <span class="type">free_area_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zone_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Commonly accessed fields:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        free_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        inactive_clean_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        inactive_dirty_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        pages_min, pages_low, pages_high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * free areas of different sizes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">inactive_clean_list</span>;</span></span><br><span class="line">    <span class="type">free_area_t</span>        free_area[MAX_ORDER];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * rarely used fields:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>            *name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        size;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Discontig memory support fields.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>    *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        zone_start_paddr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        zone_start_mapnr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span>        *<span class="title">zone_mem_map</span>;</span></span><br><span class="line">&#125; <span class="type">zone_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_DMA        0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_NORMAL        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_HIGHMEM        2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NR_ZONES        3</span></span><br></pre></td></tr></table></figure>

<p>由于NUMA结构，有多个存储节点，所以mem_map从属于具体的节点，每个存储节点都有至少两个管理区，结构pglist_data代表存储节点</p>
<p>多个存储节点通过node_next形成链表</p>
<p>node_mem_map即此存储节点的page数组</p>
<p>node_zones是该节点的最多3个管理区</p>
<p>node_zonelists是zonelist_t数组，每个zonelist_t结构代表一种页面分配策略，其中zones即zone_t指针数组，各个元素按照特定的次序指向具体的页面管理区，表示页面分配时按先后顺序尝试各个管理区。每个存储节点最多有NR_GFPINDEX种分配策略</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="type">zone_t</span> node_zones[MAX_NR_ZONES];</span><br><span class="line">    <span class="type">zonelist_t</span> node_zonelists[NR_GFPINDEX];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *valid_addr_bitmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_paddr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_mapnr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_size;</span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node_next</span>;</span></span><br><span class="line">&#125; <span class="type">pg_data_t</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zonelist_struct</span> &#123;</span></span><br><span class="line">    <span class="type">zone_t</span> * zones [MAX_NR_ZONES+<span class="number">1</span>]; <span class="comment">// NULL delimited</span></span><br><span class="line">    <span class="type">int</span> gfp_mask;</span><br><span class="line">&#125; <span class="type">zonelist_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_GFPINDEX        0x100</span></span><br></pre></td></tr></table></figure>

<h2 id="虚拟地址管理"><a href="#虚拟地址管理" class="headerlink" title="虚拟地址管理"></a>虚拟地址管理</h2><p>vm_area_struct代表了一个虚存空间</p>
<p>范围内页面的访问权限和属性相同,vm_page_prot和vm_flags即代表此</p>
<p>属于同一个进程的所有区间都要按虚存地址的高低次序通过vm_next链接在一起</p>
<p>[ vm_start , vm_end ) 决定了一个虚存空间的范围</p>
<p>vm_avl_left，vm_avl_right，vm_height构成AVL树</p>
<p>vm_ops实际上是3个函数指针，分别用于虚存区间的打开，关闭和缺页异常</p>
<p>mapping，vm_next_share，vm_pprev_share，vm_file记录页面和磁盘文件的关联</p>
<p>vm_mm指向其所属的mm_struct结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span>    <span class="comment">/* VM area parameters */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AVL tree of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="type">short</span> vm_avl_height;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vm_avl_left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vm_avl_right</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * one of the address_space-&gt;i_mmap&#123;,shared&#125; lists,</span></span><br><span class="line"><span class="comment">     * for shm areas, the list of attaches, otherwise unused.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next_share</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> **<span class="title">vm_pprev_share</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> * <span class="title">vm_ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;        <span class="comment">/* offset in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_raend;</span><br><span class="line">    <span class="type">void</span> * vm_private_data;        <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*open)(<span class="keyword">struct</span> vm_area_struct * area);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> vm_area_struct * area);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> * (*<span class="title">nopage</span>)(<span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">area</span>, <span class="title">unsigned</span> <span class="title">long</span> <span class="title">address</span>, <span class="title">int</span> <span class="title">write_access</span>);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个进程都有一个mm_struct结构，是进程整个用户空间的抽象</p>
<p>mmap是所有虚存区间的链表头</p>
<p>mmap_avl是指向所有虚存区间构成的avl树</p>
<p>mmap_cache指向最近一次用到的vm_area_struct结构</p>
<p>map_count表示链表或AVL树中有多少vm_area_struct结构</p>
<p>pgd是该进程的页表目录，注意是虚拟地址</p>
<p>一个进程只有一个mm_struct，而一个mm_struct可以被多个进程共享，即子进程可能共享父进程的mm_struct。mm_users和mm_count即为此设置的计数器</p>
<p>start_code，end_code是代码段的范围</p>
<p>start_data，end_data是数据段的范围</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>        <span class="comment">/* list of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_avl</span>;</span>    <span class="comment">/* tree of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>    <span class="comment">/* last find_vma result */</span></span><br><span class="line">    <span class="type">pgd_t</span> * pgd;</span><br><span class="line">    <span class="type">atomic_t</span> mm_users;            <span class="comment">/* How many users with user space? */</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_count;            <span class="comment">/* How many references to &quot;struct mm_struct&quot; (users count as 1) */</span></span><br><span class="line">    <span class="type">int</span> map_count;                <span class="comment">/* number of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> page_table_lock;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>        <span class="comment">/* List of all active mm&#x27;s */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rss, total_vm, locked_vm;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> def_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpu_vm_mask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> swap_cnt;    <span class="comment">/* number of pages to swap on next pass */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> swap_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="type">mm_context_t</span> context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="页面交换文件"><a href="#页面交换文件" class="headerlink" title="页面交换文件"></a>页面交换文件</h2><p>交换设备（磁盘或者普通文件）用swap_info_struct来表示</p>
<p>swap_map是一个2无符号短整数数组，每个元素代表盘上的一个物理页面，而数组的下标决定了该页面在盘上或文件中的位置，数组大小取决于页面交互设备或文件的大小，swap_map[0]不用于页面交换，记录了交换设备或文件自身的一些信息和位图。数组元素值表示该页面的分配使用计数，为0表示尚未分配。</p>
<p>lowest_bit和highest_bit说明文件供页面交换的范围</p>
<p>max表示该设备或者文件中最大的页面号，即设备或文件的物理大小</p>
<p>全局变量swap_info记录了所有用于页面交换的设备或文件</p>
<p>swap_list将这些swap_info_struct通过优先级高低链接在一起</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_info_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">kdev_t</span> swap_device;</span><br><span class="line">    <span class="type">spinlock_t</span> sdev_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">swap_file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">swavfsmnt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> * swap_map;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lowest_bit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> highest_bit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cluster_next;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cluster_nr;</span><br><span class="line">    <span class="type">int</span> prio;            <span class="comment">/* swap priority */</span></span><br><span class="line">    <span class="type">int</span> pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> max;</span><br><span class="line">    <span class="type">int</span> next;            <span class="comment">/* next entry on swap list */</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_list_t</span> <span class="title">swap_list</span> =</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_info_struct</span> <span class="title">swap_info</span>[<span class="title">MAX_SWAPFILES</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPFILE_CLUSTER 256 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_list_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> head;    <span class="comment">/* head of priority-ordered swapfile list */</span></span><br><span class="line">    <span class="type">int</span> next;    <span class="comment">/* swapfile to be used next */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类似于pte_t将物理页面和虚存页面建立联系一样</p>
<p>盘上页面使用swp_entry_t，实际上是32位数</p>
<p>高24位是offset，表示页面在一个磁盘设备或文件中的位置，即文件中的逻辑页面号</p>
<p>中间7位是type，表示该页面所属文件在swap_info数组中的下标</p>
<p>最低位永远是0，与pte_t对应，最低位P为1时表示页面在内存中，为0时表示页面不在内存中，页表项变成了一个swp_entry_t，即页表项不再指向物理页面，而是指示这个页面的去向</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line">&#125; <span class="type">swp_entry_t</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWP_TYPE(x)            (((x).val &gt;&gt; 1) &amp; 0x3f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWP_OFFSET(x)            ((x).val &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWP_ENTRY(type, offset)        ((swp_entry_t) &#123; ((type) &lt;&lt; 1) | ((offset) &lt;&lt; 8) &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pte_to_swp_entry(pte)        ((swp_entry_t) &#123; (pte).pte_low &#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swp_entry_to_pte(x)        ((pte_t) &#123; (x).val &#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="物理页面生命周期"><a href="#物理页面生命周期" class="headerlink" title="物理页面生命周期"></a>物理页面生命周期</h2><p>全局活跃页面队列 active_list</p>
<p>全局不活跃脏页面队列 inactive_dirty_list</p>
<p>每个页面管理区都有一个不活跃干净页面队列inactive_clean_list</p>
<ol>
<li><p>空闲。page通过list链入某个管理区zone的空闲队列free_area中，count为0</p>
</li>
<li><p>活跃状态。通过<code>__alloc_pages()</code>或<code>__get_free_pages</code>从某个空闲队列中分配内存页面，并将page的count置为1，page的list变为空闲。page通过lru链入活跃页面队列active_list，并且至少有一个进程用户空间的页表项指向该页面，每当为页面建立或恢复映射时，都使count增加1</p>
</li>
<li><p>不活跃状态(脏)。page通过lru链入不活跃脏页面队列inactive_dirty_list，不再有任何进程的页面表项指向该页面，每当断开页面的映射时都使count减1</p>
</li>
<li><p>不活跃状态(干净)。将不活跃脏页面的内容写入交换设备后，页面转移到某个不活跃干净页面队列中</p>
</li>
</ol>
<p>在转入不活跃状态后一段时间内页面受到访问，则又转入活跃状态，并恢复映射</p>
<p>当有需要时，就从干净页面队列中回收页面，或退回到空闲队列中，或直接另行分配</p>
<p>全局address_space数据结构swapper_space，把所有可交换内存页面管理起来，每个可交换页面的page结构都通过list链入其中一个队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">clean_pages</span>;</span>    <span class="comment">/* list of clean pages */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">dirty_pages</span>;</span>    <span class="comment">/* list of dirty pages */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">locked_pages</span>;</span>    <span class="comment">/* list of locked pages */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        nrpages;    <span class="comment">/* number of total pages */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span>    <span class="comment">/* methods */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">host</span>;</span>        <span class="comment">/* owner: inode, block_device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>    *<span class="title">i_mmap</span>;</span>    <span class="comment">/* list of private mappings */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>    *<span class="title">i_mmap_shared</span>;</span> <span class="comment">/* list of shared mappings */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        i_shared_lock;  <span class="comment">/* and spinlock protecting it */</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> <span class="title">swapper_space</span> =</span> &#123;</span><br><span class="line">    LIST_HEAD_INIT(swapper_space.clean_pages),</span><br><span class="line">    LIST_HEAD_INIT(swapper_space.dirty_pages),</span><br><span class="line">    LIST_HEAD_INIT(swapper_space.locked_pages),</span><br><span class="line">    <span class="number">0</span>,                <span class="comment">/* nrpages    */</span></span><br><span class="line">    &amp;swap_aops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="SLAB"><a href="#SLAB" class="headerlink" title="SLAB"></a>SLAB</h2><p>内核中重要的数据结构，如mm_struct，task_struct等都有自己专用的缓冲区队列，缓冲区队列是由多个slab构成的链表</p>
<p>一个slab可能由1，2，4 … 最多32个连续的物理页面构成，具体大小由内核对象的大小而异。每个slab的前端有一个slab_t结构，即slab控制块。同一种内核对象的多个slab通过slab_t中的list构成一条双向链表，每个slab链表在逻辑上分为3截，第一截是slab上所有对象都使用完的，第二截是slab上部分对象使用完的，第三截是slab上对象都处于空闲状态</p>
<p>每个slab上都有一个对象区，是这个对象数据结构的数组，元素是各个对象的起始地址</p>
<p>每个slab上还有一个对象链接数组，用来实现一个空闲对象链</p>
<p>下面是slab_t结构</p>
<p>list构成链表</p>
<p>colouroff是着色区的大小</p>
<p>s_mem指向对象区的起点</p>
<p>inuse是已分配对象的计数器</p>
<p>free指明了空闲对象链中的第一个对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        colouroff;</span><br><span class="line">    <span class="type">void</span>            *s_mem;        <span class="comment">/* including colour offset */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        inuse;        <span class="comment">/* num of objs active in slab */</span></span><br><span class="line">    <span class="type">kmem_bufctl_t</span>        <span class="built_in">free</span>;</span><br><span class="line">&#125; <span class="type">slab_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFCTL_END 0xffffFFFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    SLAB_LIMIT 0xffffFFFE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">kmem_bufctl_t</span>;</span><br></pre></td></tr></table></figure>

<p>每个对象的slab缓冲区队列都有个队列头，控制结构为kmem_cache_t</p>
<p>slabs是slab对列头</p>
<p>ctor，dtor是此种对象的构造和析构函数指针</p>
<p>firstnotfull指向队列中第一个含有空闲对象的slab’，即队列中的第2截</p>
<p>objsize是对象数据结构的大小</p>
<p>num表示每个slab上有几个对象</p>
<p>gfporder表示每个slab的大小，即2的gfporder次方</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_s</span> &#123;</span></span><br><span class="line"><span class="comment">/* 1) each alloc &amp; free */</span></span><br><span class="line">    <span class="comment">/* full, partial first, then free */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">slabs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    *<span class="title">firstnotfull</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        objsize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>         flags;    <span class="comment">/* constant flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        num;    <span class="comment">/* # of objs per slab */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        spinlock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        batchcount;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2) slab additions /removals */</span></span><br><span class="line">    <span class="comment">/* order of pgs per slab (2^n) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        gfporder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* force GFP flags, e.g. GFP_DMA */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        gfpflags;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span>            colour;        <span class="comment">/* cache colouring range */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        colour_off;    <span class="comment">/* colour offset */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        colour_next;    <span class="comment">/* cache colouring */</span></span><br><span class="line">    <span class="type">kmem_cache_t</span>        *slabp_cache;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        growing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        dflags;        <span class="comment">/* dynamic flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* constructor func */</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *, <span class="type">kmem_cache_t</span> *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* de-constructor func */</span></span><br><span class="line">    <span class="type">void</span> (*dtor)(<span class="type">void</span> *, <span class="type">kmem_cache_t</span> *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        failures;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3) cache creation/removal */</span></span><br><span class="line">    <span class="type">char</span>            name[CACHE_NAMELEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="comment">/* 4) per-cpu data */</span></span><br><span class="line">    <span class="type">cpucache_t</span>        *cpudata[NR_CPUS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STATS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        num_active;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        num_allocations;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        high_mark;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        grown;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        reaped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>         errors;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">atomic_t</span>        allochit;</span><br><span class="line">    <span class="type">atomic_t</span>        allocmiss;</span><br><span class="line">    <span class="type">atomic_t</span>        freehit;</span><br><span class="line">    <span class="type">atomic_t</span>        freemiss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每种对象的slab对列头也是用slab管理的，系统中有个总的slab队列，其对象是各个其他对象的slab队头，其队列头也是一个keme_cache_t结构，为cache_cache</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* internal cache of cache description objs */</span></span><br><span class="line"><span class="type">static</span> <span class="type">kmem_cache_t</span> cache_cache = &#123;</span><br><span class="line">    slabs:        LIST_HEAD_INIT(cache_cache.slabs),</span><br><span class="line">    firstnotfull:    &amp;cache_cache.slabs,</span><br><span class="line">    objsize:    <span class="keyword">sizeof</span>(<span class="type">kmem_cache_t</span>),</span><br><span class="line">    flags:        SLAB_NO_REAP,</span><br><span class="line">    spinlock:    SPIN_LOCK_UNLOCKED,</span><br><span class="line">    colour_off:    L1_CACHE_BYTES,</span><br><span class="line">    name:        <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>kmalloc通过内核通用缓冲区cache_sizes进行分配，也是基于slab管理的</p>
<p>其中根据缓冲区的大小分成若干队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_sizes</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>         cs_size;</span><br><span class="line">    <span class="type">kmem_cache_t</span>    *cs_cachep;</span><br><span class="line">    <span class="type">kmem_cache_t</span>    *cs_dmacachep;</span><br><span class="line">&#125; <span class="type">cache_sizes_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">cache_sizes_t</span> cache_sizes[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PAGE_SIZE == 4096</span></span><br><span class="line">    &#123;    <span class="number">32</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;    <span class="number">64</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;   <span class="number">128</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;   <span class="number">256</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;   <span class="number">512</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;  <span class="number">1024</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;  <span class="number">2048</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;  <span class="number">4096</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;  <span class="number">8192</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123; <span class="number">16384</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123; <span class="number">32768</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123; <span class="number">65536</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;<span class="number">131072</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">    &#123;     <span class="number">0</span>,    <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  </div>
</article>



      </div>
      
       <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">页表管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">物理地址管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">虚拟地址管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">页面交换文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.</span> <span class="toc-text">物理页面生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SLAB"><span class="toc-number">6.</span> <span class="toc-text">SLAB</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&text=linux内存管理"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&is_video=false&description=linux内存管理"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=linux内存管理&body=Check out this article: https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&title=linux内存管理"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sh1xo.cn/2021/06/01/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/&name=linux内存管理&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

      
      <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2022 sh1xo
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

      
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- Google Analytics -->

<!-- Disqus Comments -->


    </div>
</body>
</html>
